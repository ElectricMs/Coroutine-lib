进程线程 用户态内核态线程

动态链接库DLL

pthread相关函数复习







































### 进程、线程和协程的概念

**进程**

进程是操作系统进行资源分配的基本单位，每个进程都有自己独立内存空间。由于进程比较重量开销的资源多，占独立的内存，所以上下文进程间的切换开销大(栈、寄存器虚拟内存、文件句柄、打开的文件资源信息等)，但相对安全稳定。

**线程**

线程线程是进程的一个实体，是处理器任务调度和执行的基本单位(线程是cpu调度的基本单位)。线程只拥有一点在运行中必不可少的资源(如程序计数器一组寄存器和栈)，但是它可以和同属一个进程的其他线程共享该进程所获得的全部资源。

**协程**

是一种用户态的轻量级线程，协程的调度完全由用户控制(也就是在用户态执行)。协程拥有自己的寄存器和上下文和栈。协程调度切换时，如果是无的情况下将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器的上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。其实这点也好理解，毕竟协程只是以一种花里胡哨的方式去运行一个函数，不管实现得如何巧妙，也不可能在单线程里做到同时运行两个函数，否则还要多线程有何用?

相比于多开一个线程来操作，使用协程的好处：

- 减少了线程的重复高频创建；
- 尽量避免线程的阻塞；
- 提升代码的可维护与可理解性（毕竟不需要考虑多线程那一套东西了）；

**如果业务处理时间远小于 IO 耗时，线程切换非常频繁，那么使用协程是不错的选择；**

**并且，协程的优势并不仅仅是减少线程之间切换，从编程的角度来看，协程的引入简化了异步编程；**

**同时，协程为一些异步编程提供了无锁的解决方案；**

即：

**协程可以用同步编程的方式实现异步编程才能实现的功能；**



### 对称协程与非对称协程



### 有栈协程与无栈协程

**有栈协程:**

用独立的执行栈来保存协程的上下文信息(当前状态全部寄存器的值)。当协程被yield挂起时，有栈协程会保存当前的执行状态(例如函数调用栈，局部变量、传递的参数等)，并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地方继续执行。类似于内核态线程的实现不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。

**无栈协程:**

它不需要独立的执行栈来保存协程的上下文信息，协程的上下文都放到公共内存中，当协程被挂起时，无栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，无栈协程会将之前保存的状态从堆中取出，并从上次挂起的地方继续执行。协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。

**补充总结:**有栈和无栈的区分是看能不能任意的保存并切换嵌套函数，因为无栈不切换调用栈，所以无法做到嵌套多个函数还能像有栈一样切换。



### 独立栈与共享栈



### ucontext族函数

`ucontext_t`结构体被用来保存和恢复程序的执行环境：

```cpp
typedef struct ucontext_t{
    //指向另一个ucontext_t结构体的指针，表示当前上下文完成执行后应恢复到的上下文
    struct ucontext_t *uc_link;
    //保存了在获取上下文时当前阻塞的信号集合（信号掩码）
    sigset_t uc_sigmask;
    //定义了此上下文使用的栈
    stack_t uc_stack;
    //包含了所有必要的信息以恢复一个线程或进程的执行状态
    mcontext_t uc_mcontext;
}
```

`ucontext`族函数是Unix和类Unix操作系统（如Linux）提供的一组用于上下文切换的API，允许用户空间程序保存和恢复执行环境。这组函数对于实现协程或用户级线程非常有用，因为它们提供了比标准栈帧操作更低层次的控制。以下是`ucontext`族中主要的几个函数及其用途：

1. **getcontext(ucontext_t *ucp);**
   - 获取当前调用环境，并将其存储在由参数`ucp`指向的`ucontext_t`结构体中。这个函数可以用来保存当前的执行上下文，包括寄存器状态、信号掩码等信息。

2. **setcontext(const ucontext_t *ucp);**
   - 从由参数`ucp`指向的`ucontext_t`结构体中加载一个已保存的执行上下文，并继续执行。一旦调用了`setcontext`，程序将不会返回到调用它的位置，而是直接开始执行保存的上下文所指示的位置。

3. **makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);**
   - 修改由`ucp`指向的上下文，以便在后续调用`swapcontext`或`setcontext`时，开始执行指定的函数`func`。此函数允许你指定要传递给新函数的参数数量（`argc`）和这些参数的实际值。通过swapcontext切换到ucp上下文时开始执行func。

4. **swapcontext(ucontext_t *oucp, const ucontext_t *ucp);**
   - 保存当前的执行上下文到`oucp`指向的`ucontext_t`结构体中，并加载由`ucp`指向的新上下文以继续执行。与`setcontext`不同的是，`swapcontext`会先保存当前的上下文，这意味着可以在未来某个时刻通过再次加载这个上下文来返回到原始的执行点。

```cpp
#include<ucontext.h>
#include<stdio.h>

void func1(void *arg){
    puts(“1");
    puts(“11");
    puts("111");
    puts("1111");
}//此函数用来给makecontext使用
         
void context_test(){
    char stack[1024*128];//设置栈的空间
    ucontext_t child,main;//设置两个上下文
    getcontext(&child);//将此时的上下文信息保存到child中 初始化
    child.uc_stack.ss_sp=stack;//指定栈空间
    child.uc_stack.ss size=sizeof(stack);//指定栈空间大小
    child.uc_stack.ss flags=0;
    child.uc_link=&main;//设置后继上下文
    
    makecontext(&child,(void(*)(void))func1,8);//修改上下文让其指向func1的函数
    swapcontext(&main,&child);//切换到child上下文，保存当前上下文到main
    puts("main")//如果设置了后继上下文也就是uc_link指向了其他ucontext_t的结构体对象则makeconteXT中的函数function
    			//执行完成后会返回此处打印main，如果指向的为nullptr就直接结束
}
int main(){
    context test();
    return ;
}
```



### 锁

```cpp
#include <mutex>
#include <condition_variable>

class Semaphore {
private:
    std::mutex mtx; // 互斥锁，用于保护对count成员变量的访问，确保同一时刻只有一个线程可以修改它。
    std::condition_variable cv; // 条件变量，配合互斥锁使用，允许线程等待某个条件变为真。
    int count; // 信号量计数器，表示当前可用资源的数量。

public:
    // 构造函数，初始化信号量计数器，默认值为0。
    explicit Semaphore(int count_ = 0) : count(count_) {}

    /**
     * P操作（也称为wait），当一个线程想要访问共享资源时调用。
     * 如果count为0，表示没有可用资源，则该线程将被阻塞直到有资源可用。
     */
    void wait() {
        std::unique_lock<std::mutex> lock(mtx); // 创建一个unique_lock并自动锁定mtx。
        while (count == 0) { // 检查是否有可用资源。
            cv.wait(lock); // 若无可用资源，释放锁并阻塞当前线程，直到收到通知。
        }
        --count; // 减少计数器，表示获取了一个单位的资源。
    }

    /**
     * V操作（也称为signal），当一个线程释放其占用的资源时调用。
     * 增加计数器，并通知一个可能正在等待的线程。
     */
    void signal() {
        std::unique_lock<std::mutex> lock(mtx); // 创建一个unique_lock并自动锁定mtx。
        ++count; // 增加计数器，表示释放了一个单位的资源。
        cv.notify_one(); // 通知一个正在等待的线程（如果有），告知现在可能有可用资源了。
    }
};
```









